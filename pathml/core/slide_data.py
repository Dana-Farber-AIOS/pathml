from typing import Optional, Literal, Union, Any
from os import PathLike

from pathml.core.masks import Masks
from pathml.core.tile import Tile
from pathml.core.tiles import Tiles
from pathml.core.slide_backends import SlideBackend, OpenSlideBackend
from pathml.preprocessing.pipeline import Pipeline


class SlideData:
    """
    Main class representing a slide and its annotations. 

    Args:
        filepath (str, optional): Path to slide file on disk.
        name (str, optional): name of slide
        slide_backend (`~pathml.core.slide_backends.SlideBackend`, optional): slide backend object for interfacing with
            slide on disk.
            If ``None``, and a filepath is provided, defaults to :class:`~pathml.core.slide_backends.OpenSlideBackend`
        masks (`~pathml.core.masks.Masks`, optional): object containing {key, mask} pairs
        tiles (`~pathml.core.tiles.Tiles`, optional): object containing {coordinates, tile} pairs
        labels (collections.OrderedDict, optional): dictionary containing {key, label} pairs
    """
    def __init__(self, filepath=None, name=None, slide_backend=None, masks=None, tiles=None, labels=None, h5=None):
        # check inputs
        assert masks is None or isinstance(masks, Masks), \
            f"mask are of type {type(masks)} but must be of type pathml.core.masks.Masks"
        assert labels is None or isinstance(labels, dict), \
            f"labels are of type {type(labels)} but must be of type dict. array-like labels should be stored in masks."
        assert tiles is None or isinstance(tiles, Tiles), \
            f"tiles are of type {type(tiles)} but must be of type pathml.core.tiles.Tiles"
        assert slide_backend is None or issubclass(slide_backend, SlideBackend), \
            f"slide_backend is of type {type(slide_backend)} but must be a subclass of pathml.core.slide_backends.SlideBackend"

        # load slide using OpenSlideBackend if path is provided and backend is not specified
        if filepath is not None:
            if slide_backend is None:
                slide_backend = OpenSlideBackend
            self.slide = slide_backend(filepath)
        else:
            self.slide = None

        self.name = name
        self.masks = masks
        self.tiles = tiles
        self.labels = labels
        self.history = None
        self.h5 = h5

    def __repr__(self): 
        out = f"{self.__class__.__name__}(name={self.name}, "
        out += f"slide = {repr(self.slide)}, "
        out += f"masks={repr(self.masks)}, "
        out += f"tiles={repr(self.tiles)}, "
        out += f"labels={repr(self.labels)}, "
        out += f"history={self.history})"
        return out 

    def run(self, pipeline, tile_size=3000, tile_stride=None, level=0, tile_pad=False):
        """
        Run a preprocessing pipeline on SlideData.
        Tiles are generated by calling self.generate_tiles() and pipeline is applied to each tile.

        Args:
            pipeline (`~pathml.preprocessing.pipeline.Pipeline`): Preprocessing pipeline.
            tile_size (int, optional): Size of each tile. Defaults to 3000px
            tile_stride (int, optional): Stride between tiles. If ``None``, uses ``tile_stride = tile_size``
                for non-overlapping tiles. Defaults to ``None``.
            level (int, optional): Level to extract tiles from. Defaults to ``None``.
            tile_pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
        """
        assert isinstance(pipeline, Pipeline), \
            f"pipeline is of type {type(pipeline)} but must be of type pathml.preprocessing.pipeline.Pipeline"
        assert self.slide is not None, "cannot run pipeline because self.slide is None"

        if tile_stride is None:
            tile_stride = tile_size

        for tile in self.generate_tiles(level = level, shape = tile_size, stride = tile_stride, pad = tile_pad):
            pipeline.apply(tile)
            key = str(tile.coords)
            self.tiles.add(key, tile)

    def generate_tiles(self, shape=3000, stride=None, pad=False, level=0):
        """
        Generator over tiles.
        All pipelines must be composed of transforms acting on tiles.

        Args:
            shape (int or tuple(int)): Size of each tile. May be a tuple of (height, width) or a single integer,
                in which case square tiles of that size are generated.
            stride (int): stride between chunks. If ``None``, uses ``stride = size`` for non-overlapping chunks.
                Defaults to ``None``.
            pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
            level (int, optional): For slides with multiple levels, which level to extract tiles from.
                Defaults to 0 (highest resolution)

        Yields:
            np.ndarray: Extracted chunk of dimension (size, size, 3)
        """
        assert isinstance(shape, int) or (isinstance(shape, tuple) and len(shape) == 2), \
            f"input shape {shape} invalid. Must be a tuple of (H, W), or a single integer for square tiles"
        if isinstance(shape, int):
            shape = (shape, shape)
        assert stride is None or isinstance(stride, int) or (isinstance(stride, tuple) and len(stride) == 2), \
            f"input stride {stride} invalid. Must be a tuple of (stride_H, stride_W), or a single int"
        assert isinstance(level, int), f"level {level} invalid. Must be an int."

        if stride is None:
            stride = shape
        elif isinstance(stride, int):
            stride = (stride, stride)

        i, j = self.slide.get_image_shape(level = level)

        stride_i, stride_j = stride

        if pad:
            n_chunk_i = i // stride_i + 1
            n_chunk_j = j // stride_j + 1

        else:
            n_chunk_i = (i - shape[0]) // stride_i + 1
            n_chunk_j = (j - shape[1]) // stride_j + 1

        for ix_i in range(n_chunk_i):
            for ix_j in range(n_chunk_j):
                coords = (int(ix_j * stride_j), int(ix_i * stride_i))
                # get image for tile
                tile_im = self.slide.extract_region(location = coords, size = shape, level = level)
                # get mask(s) for tile
                tile_masks = None
                if self.masks is not None:
                    slices = [
                        slice(int(ix_j * stride), int(ix_j * stride + shape[0])),
                        slice(int(ix_i * stride), int(ix_i * stride) + shape[1])
                    ]
                    tile_masks = self.masks.slice(slices)
                yield Tile(image = tile_im, coords = coords, masks = tile_masks, slidetype = type(self))

    def plot(self):
        raise NotImplementedError

    def save(self):
        raise NotImplementedError

    def _write_h5(
        self,
        filename: Optional[PathLike] = None,
        compression: Optional[Literal["gzip", "lzf"]] = None,
        compression_opts: Union[int, Any] = None,
    ):
        raise NotImplementedError
