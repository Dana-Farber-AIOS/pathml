import numpy as np
from typing import Optional, Literal, Union, Any
from os import PathLike

from pathml.core.slide import Slide
from pathml.core.masks import Masks
from pathml.core.tiles import Tile, Tiles
from pathml.preprocessing.transforms import Transform
from pathml.preprocessing.pipeline import Pipeline


class SlideData:
    """
    Main class representing a slide and its annotations. 
    Preprocessing pipelines change the state of this object.
    Declared by subclassing Slide

    Attributes:
        filepath (str): Path to slide file on disk.
        name (str): name of slide
        size (int): total size of slide in pixels 
        slide (`~pathml.core.slide_backends.SlideBackend`): slide backend object
        masks (`~pathml.core.masks.Masks`, optional): object containing {key, mask} pairs
        tiles (`~pathml.core.tiles.Tiles`, optional): object containing {coordinates, tile} pairs
        labels (collections.OrderedDict, optional): dictionary containing {key, label} pairs
        history (list): the history of operations applied to the SlideData object
    """
    def __init__(self, filepath, name=None, slide=None, masks=None, tiles=None, labels=None, h5=None):
        self.filepath = filepath
        self.name = name
        assert isinstance(slide, Slide), f"slide is of type {type(slide)} but must be a subclass of pathml.core.slide.Slide"
        self.slide = slide
        self._slidetype = type(slide)
        self.name = slide.name
        self.shape = None if slide is None else slide.shape
        assert isinstance(masks, (type(None), Masks)), f"mask are of type {type(masks)} but must be of type pathml.core.masks.Masks"
        self.masks = masks 
        assert isinstance(tiles, (type(None), Tiles)), f"tiles are of type {type(tiles)} but must be of type pathml.core.tiles.Tiles"
        self.tiles = tiles
        assert isinstance(labels, dict), f"labels are of type {type(labels)} but must be of type dict. array-like labels should be stored in masks."
        self.labels = labels
        self.history = []
        self.h5 = h5

    def __repr__(self): 
        out = f"{self.__class__.__name__}(slide={repr(self.slide)}, "
        out += f"slide={self.slide.shape}, "
        out += f"masks={repr(self.masks)}, "
        out += f"tiles={repr(self.tiles)}, "
        out += f"labels={self.labels}, "
        out += f"history={self.history})"
        return out 

    def run(self, pipeline, tile_size=3000, tile_stride=None, level=None, tile_pad=False):
        """
        Run a preprocessing pipeline on SlideData.
        Tiles are generated by calling self.generate_tiles() and pipeline is applied to each tile.

        Args:
            pipeline (`~pathml.preprocessing.pipeline.Pipeline`): Preprocessing pipeline.
            tile_size (int, optional): Size of each tile. Defaults to 3000px
            tile_stride (int, optional): Stride between tiles. If ``None``, uses ``tile_stride = tile_size``
                for non-overlapping tiles. Defaults to ``None``.
            level (int, optional): Level to extract tiles from. Defaults to ``None``.
            tile_pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
        """
        assert isinstance(pipeline, Pipeline), \
            f"pipeline is of type {type(pipeline)} but must be of type pathml.preprocessing.pipeline.Pipeline"

        if tile_stride is None:
            tile_stride = tile_size

        for tile in self.generate_tiles(level = level, shape = tile_size, stride = tile_stride, pad = tile_pad):
            pipeline.apply(tile)
            # what should the key be?
            self.tiles.add(key, tile)

    def generate_tiles(self, shape=3000, stride=None, pad=False, level=None):
        """
        Generator over tiles.
        All pipelines must be composed of transforms acting on tiles.

        Args:
            shape (int or tuple(int)): Size of each tile. May be a tuple of (height, width) or a single integer,
                in which case square tiles of that size are generated.
            stride (int): stride between chunks. If ``None``, uses ``stride = size`` for non-overlapping chunks.
                Defaults to ``None``.
            pad (bool): How to handle chunks on the edges. If ``True``, these edge chunks will be zero-padded
                symmetrically and yielded with the other chunks. If ``False``, incomplete edge chunks will be ignored.
                Defaults to ``False``.
            level (int, optional): For slides with multiple levels, which level to extract tiles from.
                Defaults to ``None``.

        Yields:
            np.ndarray: Extracted chunk of dimension (size, size, 3)
        """
        if isinstance(shape, int):
            shape = (shape, shape)
        if stride is None:
            stride = shape

        i, j = self.slide.get_image_shape(level = level)

        stride_i, stride_j = stride

        if pad:
            n_chunk_i = i // stride_i + 1
            n_chunk_j = j // stride_j + 1

        else:
            n_chunk_i = (i - shape[0]) // stride_i + 1
            n_chunk_j = (j - shape[1]) // stride_j + 1

        for ix_i in range(n_chunk_i):
            for ix_j in range(n_chunk_j):
                coords = (int(ix_j * stride_j), int(ix_i * stride_i))
                # get image for tile
                tile_im = self.slide.extract_tile(location = coords, size = shape, level = level)
                # get mask(s) for tile
                tile_masks = None
                if self.masks is not None:
                    # TODO: test this line
                    slices = [
                        slice(int(ix_j * stride), int(ix_j * stride + shape[0])),
                        slice(int(ix_i * stride), int(ix_i * stride) + shape[1])
                    ]
                    tile_masks = self.masks.slice(slices)
                yield Tile(image = tile_im, coords = coords, masks = tile_masks, slidetype = type(self))

    def plot():
        """
        Args:
            location
            tile = True
            size
            downsample
            mask(str)
            save
        """
        raise NotImplementedError() 

    def write_h5(
        self,
        filename: Optional[PathLike] = None,
        compression: Optional[Literal["gzip", "lzf"]] = None,
        compression_opts: Union[int, Any] = None,
    ):
        raise NotImplementedError()

